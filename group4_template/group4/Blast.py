import os
import re
import time
import requests
from group4_template.group4.utils import *  # URL, PUT_Request, GET_Request, Program, Database_PDB, RID, GET_query_head, url_request_head, DATA_CACHE


# Debug/auxiliary functions:

def _check_query(seq: str, program: str = Program, database: str = Database_PDB, filters: str = "",
                 email: str = "") -> str:

    """Function for printing the query to submit. Use for debug purpose.

    :param seq: str.
        -Aminoacidic sequence to be aligned.
    :param program: str.
        -program which will be used to blast (default is: "PROGRAM=blastp&").
    :param database: str.
        -database used in the blast blast (default is: "DATABASE=pdb").
    :param filters: str.
        -filters that may be added to the put query (e.g "&THRESHOLD=13).
    :param email: str.
        -email which could be used by NCBI for contact in case of issues.
    :return: str.
        -query which will be submitted to blast server.
    """
    query = "QUERY=" + seq + "&"
    PUT_query = URL + PUT_Request + query + program + database + filters + email
    print(PUT_query)
    return PUT_query


def _clean_cache(file:str=None)->None:

    """ Delete all the cached files in the cache directory. Is possible to specify which file to delete selectively.

    :param file: str.
            -file to be erased.
    return: None.
    """
    for f in os.listdir(DATA_CACHE):
        if file is None:
            os.remove(os.path.join(DATA_CACHE, f))
        else:
            os.remove(os.path.join(DATA_CACHE, file))
    return


################################################################################################################

# Main functions:

def query_Blast(seq: str, program: str = Program, database: str = Database_PDB, filters: str = "",
    email: str = "", debug_mode=False):

    """Submit a PUT query to Blast and return the response object.

    :param seq: str
        -Aminoacidic sequence to be aligned.
    :param program: str
        -program which will be used to blast (default is: "PROGRAM=blastp&").
    :param database: str
        -database used in the blast blast (default is: "DATABASE=pdb").
    :param filters: str
        -filters that may be added to the put query (e.g "&THRESHOLD=13).
    :param filters: str
        -email which could be used by NCBI for contact in case of issues.
    :param debug_mode: bool
        -If True it will print the query submitted to the server
    :return: response object.
        -The response obtained from the request.
    """
    query = "QUERY=" + seq + "&"
    PUT_query = URL + PUT_Request + query + program + database + filters + email
    if debug_mode:
        print(PUT_query)
    p = requests.put(PUT_query)  # Submit the request to the BLAST site
    return p


def extract_attribute(p, rid_attr:str=RID)->str:

    """ Will go line by line through a file, searching for mentions of the rid_attribute and extract/return the value
    associated with it
    :param p: str
        -response object generated by querying the server
    :return: str.
        -attribute found in the response file (Default is "RID =").
    """
    put_response = p.text  # get html/text file
    for line in put_response.splitlines():
        if rid_attr in line:
            attribute_value = re.sub(rid_attr, "", line)
            attribute_value = "".join(attribute_value.split())
            return attribute_value


def check_request_status(rid:str)->str:

    """ Check the status ID and when ready download the results as html file

    :param rid: str
        -Request ID returned when the search was submitted
    :return: str
        -Status of the research
        """
    url_submit = URL + 'CMD=Get&FORMAT_OBJECT=SearchInfo&RID=' + rid
    # Submit the request of the status:
    submit_request = requests.get(url_submit)
    query_status = extract_attribute(submit_request, "Status=")
    return query_status


def get_results(rid:str, response_format:str="html"):

    """Once the status of the request is ready, it is possible to get the results of the query in html or json.zip format
    :param rid: str
        -Request ID returned when the search was submitted
    :param response_format: str
        -Format type of the response results (default is "html", allowed is "json")
    :return: response object
        -response object generated after submitting the get query
        """
    GET_query = GET_query_head + rid  # /CMD=get&RID=rid"
    if response_format == "json":
        GET_query = GET_query_head + rid + "&FORMAT_TYPE=JSON2"  # /CMD=get&RID=rid&FORMAT_TYPE=JSON2""   
    s = requests.get(GET_query)
    if not s.ok:
        print(f"{GET_query} returned bad status code: {s.status_code}")
        return
    else:
        print(GET_query)
        return s


def download_html_file(s, filename:str="temporary.html"):

    """Given the result of a request (s) with html content, save it in a file stored in the home directory.
    :param s: response object
        -response object generated after submitting the get query
    :param filename: str
        -name of the file where the html will be written (default is "temporary.html")
    :return: response object
        -response object generated after submitting the get query"""
    assert filename.lower().endswith('.html'), print("save with html file extension")
    path = os.path.join(DATA_CACHE, filename)
    with open(path, "w") as file_handle:
        file_handle.write(s.text)
        print(f"The html results have been saved in the home folder as {filename}")
    return path


def download_zip_json_file(s, filename:str="temporary.zip"):

    """Given the results of a request (s) with zipped json content, save it in a file stored in the home directory.
    :param s: response object
        -response object generated after submitting the get query
    :param filename: str
        -name of the file where the json will be written and zipped(default is "temporary.zip")
    :return: response object
        -response object generated after submitting the get query
        """
    path = os.path.join(DATA_CACHE, filename)
    with open(path, 'wb') as file_handle:  # write the zip file
        file_handle.write(s.content)
        print(f"The zip/json results have been saved in the home folder as {filename}")
    return path


def html_reader(filepath:str)->list:

    """Read a html file and returns the list of accessions IDs
    :param filepath: str
        -name of the html file where the results are stored
    :return: list
        -list of the predicted protein (accession IDs)"""
    assert filepath.lower().endswith('.html'), print("accept only html files")
    with open(filepath, "r") as f:
        list_accessions = []
        for line in f.readlines():
            if "<tr id=" in line:
                i = line.index("<tr id=")
                i2 = line.index("ind=")
                accession = (line[i + 12:i2 - 2])
                list_accessions.append(accession)
    return list_accessions


def zip_reader(filepath):
    """Extract a zip json file and returns the list of accessions IDs

    :param filepath: str
        -name of the zip file where the results are stored)
    :return: list
        -list of the predicted protein (accession IDs)"""

    from zipfile import ZipFile
    import json
    assert filepath.lower().endswith('.zip'), print("accept only zip files")
    list_accessions = []
    zf = ZipFile(filepath)  # convert the zip file to a python object
    for filename in zf.namelist():
        if "_" in filename:  # Take only the file with the results
            with zf.open(filename) as f:
                data = f.read()
                d = json.loads(data)
                list_of_hits = d["BlastOutput2"]['report']['results']['search']['hits']
                for e in list_of_hits:
                    ID = e['description'][0]["id"]
                    list_accessions.append(ID)
    return list_accessions


# def is_html(output_file):
#     """Assess that the output file is in html format."""
#     assert output_file[-4:] == "html", print("Save the results in html file format!")


def Blast_sequence(seq: str, filename = "temporary", program: str = Program, database: str = Database_PDB,
                   filters: str = "", email: str = "", file_type = "html", keep_files = True)->list:

    """Given sequence, it blast it against the specified database and return list of possible proteins.
    :param seq: str.
        -Aminoacidic sequence to be aligned.
    :param program: str.
        -program which will be used to blast (default is: "PROGRAM=blastp&").
    :param database: str.
        -database used in the blast blast (default is: "DATABASE=pdb").
    :param filters: str.
        -filters that may be added to the put query (e.g "&THRESHOLD=13).
    :param email: str.
        -email which could be used by NCBI for contact in case of issues.
    :param filename: str.
        -file where the results will be stored if keep_file is in default mode.
    param keep_files: bool
        -If False will erase the saved file results, else it will keep them
    :return: str.
        -query which will be submitted to blast server.
    """
    p = query_Blast(seq, program, database, filters, email, debug_mode=False)  # Submit the request to the BLAST site
    rid = extract_attribute(p, RID)  # Extract the request ID (rid) that will be used for next steps
    while True:
        Status = check_request_status(rid)
        if Status == 'READY':
            print("The status is ready")
            break
        else:
            print("Will wait and check in 60 seconds")
            time.sleep(60)  # Do not poll for any single RID more often than once a minute.
    s = get_results(rid, response_format=file_type)
    print("The sequence was successfully aligned!")
    if file_type == "json":
        filename = filename + ".zip"
        path = download_zip_json_file(s, filename)  # save the zip/json file
        list_matches = zip_reader(path)  # extract the hits IDs
    else:
        filename = filename + ".html"
        path = download_html_file(s, filename)  # save the zip/json file
        list_matches = html_reader(path)  # extract the hits IDs

    if keep_files is False:  # delete the result files
        os.remove(path)
    return list_matches


def Blast_orfs(OrfList:list, filename:str="temporary", program:str = Program, database: str = Database_PDB,
               filters: str = "", email: str = "", file_type="html", keep_files=True):

    """Given a list of orfs it blasts them against pdb database and return a dictionary with the orf as key and the list of
    alignments as value
    :param OrfList: List
        -list of sequences to be aligned.
    :param program: str.
        -program which will be used to blast (default is: "PROGRAM=blastp&").
    :param database: str.
        -database used in the blast blast (default is: "DATABASE=pdb").
    :param filters: str.
        -filters that may be added to the put query (e.g "&THRESHOLD=13).
    :param email: str.
        -email which could be used by NCBI for contact in case of issues.
    :param filename: str.
        -file where the results will be stored if keep_file is in default mode.
    param keep_files: bool
        -If False will erase the saved file results, else it will keep them
    :return: str.
        -query which will be submitted to blast server.
    """
    n = 0
    dict_matches = {}
    for orf in OrfList:
        n += 1
        file_name = "orf" + str(n) + "_" + filename
        list_matches = Blast_sequence(orf, filename=file_name, program=program, database=database, filters=filters,
                                      email=email, file_type=file_type, keep_files=keep_files)
        dict_matches[orf] = list_matches
        time.sleep(10)  # Do not contact the server more often than once every 10 seconds.
    print("The job is complete for all the sequences!")
    return dict_matches
